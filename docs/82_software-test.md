# Software Test

- 소프트웨어가 의도한 대로 동작하는지를 테스트
- 소스코드가 좋을수록 테스트 코드 작성도 수월해진다.
- 테스트코드도 유지보수를 위하여 관심사를 분리해야 한다.
- 옛날에는 소프트웨어가 올바르게 동작하는지를 확인하는 테스트팀(QA)이 별도로 존재하고, 개발자는 테스팅 과정에 큰 관여를 하지 않았다.
- 최근에는 개발자가 자동화 할 수 있는 소프트웨어 테스트를 구현하고 실행하는 것이 보편적이다.
- 소프트웨어 테스트는 현대 개발에서 필수적인 요소로 자리잡았고, 각 진영마다 소프트웨어 테스트를 위해 사용할 수 있는 라이브러리들이 개발되어 있다.

## 장점

- 컴퓨터를 통해서 실행하기에 사람이 실행하는 것보다 빠르다.
- 정해진 스크립트에 따라 일관성 있게 동작하므로 사람이 테스트할 때 발생 가능한 human error 를 피할 수 있다.
- 소프트웨어 테스트를 실행하며 개발할 경우, 개발 중인 소프트웨어가 정상적으로 동작하는지 수시로 확인할 수 있고, 피드백을 빠른 주기로 받을 수 있다.
- 자동화된 테스트는 추후 CI/CD 와 같은 프로세스에서도 해당 소스 코드들이 정상적으로 동작하는지 확인하는 과정에서 사용할 수 있다.

## 종류

- 테스트가 확인하고자 하는 범위, 복잡성에 따라 3가지로 나눌 수 있다.
- 아래의 테스트들은 동적 분석 테스트의 범주에 든다.  
  cf. lint 는 정적 분석 테스트이다.

### Unit Test(단위 테스트)

- 테스트 중에서 가장 low level 이며, 가장 작은 범위를 테스트
- 개별 함수, 메서드, 클래스, 컴포넌트 등 모듈의 동작을 테스트
- 외부 요소의 영향 없이 특정 요소만을 단독으로 테스트
- 가장 간단한 형태의 테스트로 실행하는 데 가장 적은 비용이 듬
- 개발 과정에서 가장 빈번하게 수행 가능
- e.g. 컴포넌트 안에서 렌더링이 정상적으로 이루어지는가?

### Integration Test(통합 테스트)

- 두 개 이상의 모듈이 결합해서 동작을 잘 수행하는지 테스트
- 여러 모듈들을 통합하는 과정이 필요하기 때문에 Unit Test 보다는 많은 비용이 듬  
  그러나 Unit Test 와 Integration Test 모두 큰 비용이 드는 편이 아님
- e.g. Redux 등 상태 관리 라이브러리와 통합했을 때 최종적으로 의도한 결과를 도출하는가?

### End-to-End Test(E2E Test)

- 실제 유저가 애플리케이션을 사용하는 것과 유사한 환경을 구축한 후, 유저의 동작을 모방하는 테스트
- 환경 및 유저의 행동 시나리오를 구축해야 하기에 큰 비용이 듬
- 따라서 소스코드에 변화가 있을 때마다 빈번하게 수행 불가능
- 핵심 기능에 대해 E2E 테스트를 구축한 후, 확인이 필요한 순간에만 실행하는 것이 일반적
- 프론트엔드에서는 실제 브라우저와 유사한 환경을 구축한 후, 실제 여러가지 이벤트를 발생시킨 후 일련의 과정을 테스트
- e.g. 회원가입의 전체 플로우를 테스트
- Cypress: 기업용으로는 유료

## JavaScript 테스트

- 라이브러리 종류: Jest, Mocha, Chai
- 우리가 일반적으로 소프트웨어를 테스트 하는 과정...

1. 특정 동작을 수행한다.
2. 동작을 수행한 결과가 기대한 상황과 일치하는지 판단한다.

### Jest

- NPM 다운로드 수가 높으며, CRA 에서도 Jest 를 포함하여 환경을 구성하는 등 사실상 표준으로서 사용되고 있음
- 테스트 결과를 PASS / FAIL 로 표시
- `*.test.*` 형태의 파일명을 테스트 파일로 인식

1. 특정 동작을 수행한다.
2. Matcher 를 통해 실제 결과와 기대값이 맞는지 검증한다.

#### test(), it()

- `test()`, `it()`: 하나의 특정한 동작을 수행하기 위한 함수
- `test(”테스트 이름", callback)` 에서 callback 은 `expect().matcher()` 형태를 갖는다.  
  하나의 callback 안에는 여러 `expect` 를 수행할 수 있다.

```
test("테스트 이름", () => {
  expect(<test-func>).<matcher>(<expected-value>);
  expect(<test-func>).<matcher>(<expected-value>);
  })
```

- 테스트 이름은 테스트 결과 FAIL 시 나타나므로 자세히 작성한다.
- `describe()`:  
  각 테스트 코드를 기능별로 묶거나 중복되는 코드가 있을 때 사용한다.  
  영어 문장 완성을 위해 내부의 `test()` 를 `it()` 으로 변경한다. 기능상 차이는 없다.  
  각 테스트 코드가 무엇을 하는지 알기 힘들어지고, `describe()` 내부 코드를 수정하면 연관된 테스트 코드 전체가 영향을 받을 위험성이 있으므로 `describe()` 대신 함수로 추출하는 방법을 고려할 수 있다.
  - `beforeAll(()=>{})`: 코드 실행 전 한번 실행
  - `beforeEach(()=>{})`: 각 테스트 코드 실행 전에 실행
  - `afterAll(()=>{})`: 코드 실행 후 한번 실행
  - `afterEach(()=>{})`: 각 테스트 코드 실행 후에 실행

#### Matcher

- 기대한 상황과 일치하는지 판단하는 함수들

  - `toBe()`: `expect` 의 값이 `toBe` 의 인자와 일치하는지 검사
  - `toEqual()`: Object 의 각 요소들을 재귀적으로 검사하여 두 객체가 동일한지 판단
  - `toBeNull, toBeUndefined`
  - `toBeGreaterThan`, `toBeGreaterThanOrEqual`, `toBeLessThan`, `toBeLesttThanOrEqual`: 숫자값 검증
  - `toContain`: Iterable 한 객체들이 특정 요소를 포함하고 있는지 검증
  - `not`: matcher 의 기대값을 반대로 반대로 변경 `expect(n).not.toBeUndefined();`

## React 테스트

- Enzyme: 구현(구체) 중심 테스트, React-Testing-Library(RTL): 결과(추상) 중심 테스트

  - 구현 중심 테스트:  
    특정 버튼을 클릭하면 컴포넌트의 state 가 변한다. 그리고 UI 에 반영된다.  
    소스코드를 수정하면 테스트 코드도 수정해야 한다. 그래서 테스트 코드를 변경해야 하는 경우가 잦아진다.
  - 결과 중심 테스트:  
    특정 버튼을 글릭하면 화면에 특정 결과가 나와야 한다.  
    겉으로 보이는 동작을 그대로 유지하고 내부 구현만 변경한다면 테스트 코드를 변경할 필요가 없다.

### Jest + RTL

- RTL: NPM 다운로드 수가 높으며, CRA 기본 구성에 포함되어있고, React 공식 문서에서 권장하는 라이브러리
- 리액티 컴포넌트를 렌더링하고, 특정 요소에 접근할 수 있도록 하는 기능을 제공한다.
- `@testing-library/user-event`:
  - 실제 유저 행동처럼 특정 element 에서 이벤트를 발생시키는 라이브러리
- `@testing-library/jest-dom`:
  - element 가 DOM 상에 존재하는지, 특정 property 를 가지고 있는지 검사하는 라이브러리

#### API

- `screen`: 현재 렌더링이 진행되고 있는 화면으로 document.body와 동일하다.  
   현재 화면에 렌더링된 요소들에 관련된 여러 메서드들을 확인할 수 있다.

  1. DOM tree 출력

  - `screen.debug`:
    호출한 시점의 렌더링된 DOM tree를 터미널에서 확인할 수 있다.

  2. 렌더링된 요소들에 접근

  - `screen.getBy...`: 해당 요소가 현재 DOM 상에 있는지 동기적으로 확인하여 없을 경우 예외를 던진다.
  - `screen.queryBy...`: getBy 와 동일하게 동작하지만 찾는 요소가 없을 경우 예외 대신 `null` 을 반환한다.
  - `screen.findBy...`: 해당 요소가 현재 DOM 상에 있는지 비동적으로 확인한다. 해당 요소를 찾기 위해 일정 시간을 기다린 후, 시간이 지난 후에도 찾을 수 없을 때 예외를 던진다.
    e.g.
    - `getByRole` tag 기준으로 가져오므로 가장 권장되는 메서드
    - `getByText`
    - `getByLabelText`
    - `getByPlaceholderText`
    - `getByDisplayValue`
    - `getByAltText`
    - `getByTitle`
    - `getByTestId`

  3. userEvent
     - `testing-library/user-event` 라이브러리를 사용해 실제 DOM상에서 이벤트를 발생시킬 수 있다. `userEvent.<event-name>(<element>)`

## TDD(Test Driven Development)

- 테스트 코드를 먼저 작성하고, 그 후 실제 코드를 작성
- Red-Green-Blue 의 3단계를 거친다.

1. Red: 실제 구현을 하기 전, 먼저 실패하는 테스트 코드를 작성 후 테스트 실행. 실제 코드가 작성되지 않았기에 테스트 코드는 당연히 실패
2. Green: 테스트를 통과하기 위해 가장 간단한 형태로 코드를 작성 후 테스트 실행. 실제 구현이 되었기에 테스트 통과
3. Blue: Green 단계의 코드를 더 좋은 형태로 refactoring. 이 과정에서 지속적으로 테스트를 실행해서 테스트가 통과하는지 확인

### 장점

- 실시간으로 피드백을 받으므로 코드 작성 과정에서 확신 및 자신감을 얻을 수 있다.
- 구현을 잘못한 경우 실제 브라우저 테스트 이전에 바로 확인할 수 있다.
- 코드의 동작이 명확해진다: 어떻게 코드를 짜야할지가 아닌, 무슨 코드를 짜야할지부터 고민하게 된다.
  - 이 코드가 어떤 식으로 동작해야 하는지 먼저 생각하게 됨
  - 사용자의 관점에서 어떻게 사용할지에 초점을 맞춰 생각할 수 있음
  - 내가 무엇을 만들어야 할지는 알지만, 어떻게 만들어야 할지 모를 때 적용하기 좋음
